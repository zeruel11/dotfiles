#!/usr/bin/env bash
#vivaldi sessions sync

DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
# log file size
maxsize=900000
baksize=1000000
# paths - change these as needed
vivaldiSession="$(cygpath $USERPROFILE)/AppData/Local/Vivaldi/User Data/Default/Sessions"
dotfiles="$(cygpath $USERPROFILE)/dotfiles"
dotfilesDir="vivaldi_sessions"
# preview coloring
grepSysCol="mt=1;93;44"
grepSendCol="mt=1;34"
grepSkipCol="mt=1;35"
grepDelCol="mt=1;31"
grepUnchCol="mt=1;32"
grepSysMsg='(total:).*|(sending incremental file list)|(delta-transmission).*|.*(bytes\/sec)|.*(\(DRY RUN\))|$'
grepSendMsg='^(\[sender\]).*|$'
grepSkipMsg='(not creating new file).*|$'
grepDelMsg='(deleting).*|$'
grepUnchMsg='.*(uptodate)$|$'
# logfiles
runLog="$(basename $0).$HOSTNAME.log"
dryLog="$(basename $0).$HOSTNAME.DRY_RUN"

function usage() {
	cat <<HELP_USAGE

    usage: $(basename $0) [ps|pl]

    -h, --help			Print this message
    ps, push			Sync current directory to git repo
    pl, pull			Sync git repo to current dir
HELP_USAGE

	exit 0
}

# REVIEW dunno how to make this work with expanded bash path variable
# function check_dir() {
# 	local arg="$*"
# 	echo $arg
# 	local files=($arg)
# 	echo ${#files[@]}
# 	[ ${#files[@]} -gt 1 ] || [ ${#files[@]} -eq 1 ] && [ -e "${files[0]}" ]
# }

function path_input() {
	read -e -p "Please enter path to vivaldi sessions: " source
	# if check_dir "$HOME/.bin/.filter*"; then
	# 	echo true
	# fi
	for f in "$source"*.bin; do

		## Check if the glob gets expanded to existing files.
		## If not, f here will be exactly the pattern above
		## and the exists test will evaluate to false.
		if [ ! -e "$f" ]; then
			echo -e "\e[30;43mWARNING: directory $source/<vivaldiSessions>.bin not found (wrong sync dir?), exiting...\e[0m"
			exit 1
		else
			break
		fi
	done
}

function define_source() {
	if [ ! -d "$dotfiles" ]; then
		echo -e "\e[30;43mWARNING: $dotfiles not found, exiting...\e[0m"
		exit 1
	fi
	if [ -d "$vivaldiSession" ]; then
		read -p $'\e[44mVivaldi session directory found on '"$vivaldiSession"$'\e[0m\n' -t 5
		source="$vivaldiSession"
	else
		echo -e "\e[31mVivaldi session directory not found. Is it installed?\e[0m"
		path_input
	fi
}

function command_exception() {
	if [ "$1" != "" ]; then
		echo "Command $sync does not accept more arguments"
		usage
	fi
}

function main_logic() {
	rsync -Ccazvvn "$1" "$2" | tee "$HOME/.logs/$dryLog" | GREP_COLORS="$grepSysCol" egrep --color=always "$grepSysMsg" | GREP_COLORS="$grepSendCol" egrep --color=always "$grepSendMsg" | GREP_COLORS="$grepDelCol" egrep --color=always "$grepDelMsg" | GREP_COLORS="$grepUnchCol" egrep --color=always "$grepUnchMsg" | less -R
	read -p "Confirm $sync? [no] " yesOrYes
	yesOrYes=${yesOrYes:-no}
	if [ "$yesOrYes" == 'yes' ] || [ "$yesOrYes" == 'y' ]; then
		rsync -Ccazv "$1" "$2" --log-file="$HOME/.logs/$runLog" && rm "$HOME/.logs/$dryLog"
		if [ -f "$dotfiles/.logs/$runLog" ] && [ -f "$HOME/.logs/$runLog" ]; then
			diff -u $dotfiles/.logs/$runLog $HOME/.logs/$runLog | grep -E "^\+" | sed -E 's/^\+//' >>$dotfiles/.logs/$runLog
			cp "$dotfiles/.logs/$runLog" "$HOME/.logs/"
		else
			cp "$HOME/.logs/$runLog" "$dotfiles/.logs/"
		fi
	fi
}

function command_param() {
	case $1 in

	pl | pull)
		sync="pull"
		define_source
		echo -e "\e[44m${sync[@]^}ing Vivaldi sessions\e[0m"
		main_logic "$dotfiles/$dotfilesDir/" "$source/"
		;;

	ps | push)
		sync="push"
		define_source
		echo -e "\e[44m${sync[@]^}ing Vivaldi sessions\e[0m"
		main_logic "$source/" "$dotfiles/$dotfilesDir/"
		;;
	df | diff)
		sync="diff"
		define_source
		diff "$dotfiles/$dotfilesDir/" "$source/"
		;;

	lg | log | logs)
		sync="logs"
		command_exception $2
		if [ -f "$HOME/.logs/$dryLog" ]; then
			read -p $'\e[44mFound DRY_RUN log on '"$HOME/.logs/$dryLog"$', opening...\e[0m' -t 5
			cat "$HOME/.logs/$dryLog" | GREP_COLORS="$grepSysCol" egrep --color=always "$grepSysMsg" | GREP_COLORS="$grepSendCol" egrep --color=always "$grepSendMsg" | GREP_COLORS="$grepDelCol" egrep --color=always "$grepDelMsg" | GREP_COLORS="$grepUnchCol" egrep --color=always "$grepUnchMsg" | less -R
		else
			read -p $'\e[44mFound log on '"$HOME/.logs/$runLog"$', opening...\e[0m' -t 5
			cat "$HOME/.logs/$runLog" | GREP_COLORS="$grepSysCol" egrep --color=always "$grepSysMsg" | GREP_COLORS="$grepSendCol" egrep --color=always "$grepSendMsg" | GREP_COLORS="$grepDelCol" egrep --color=always "$grepDelMsg" | GREP_COLORS="$grepUnchCol" egrep --color=always "$grepUnchMsg" | less -R
		fi
		;;

	"" | -h | --help)
		usage
		;;

	*)
		echo "Unknown option - $1"
		usage
		;;
	esac
}

if [ $# -gt 1 ]; then
	for ((i = 2; i <= $#; i++)); do
		echo "No parameter ${!i} found"
	done
	usage
else
	command_param $1
fi

# log archiving
if [ -f "$HOME/.logs/$runLog" ]; then
	filesize=$(stat -c%s "$HOME/.logs/$runLog")
	if ((filesize > maxsize)) && ((filesize < baksize)); then
		echo -e "\e[30;43mCaution: Log file is 900kb large. Consider backing up and/or deleting. Log will be automatically archived soon.\e[0m"
	elif ((filesize > baksize)); then
		echo -e "\e[34;43mAttention: Log file is 1mb large. Archiving...\e[0m"
		for i in {1..3}; do
			if [ ! -f "$HOME/.logs/$runLog.bak$i" ]; then
				tar -czvf "$HOME/.logs/$runLog.bak$i" "$HOME/.logs/$runLog" --remove-files
				echo -e "\e[34mLog file archived to $HOME/.logs/$runLog.bak$i (uses tar gzip). Note that log backups are not sent to Git versioning.\e[0m"
				break
			elif [ -f "$HOME/.logs/$runLog.bak1" ] && [ -f "$HOME/.logs/$runLog.bak2" ] && [ -f "$HOME/.logs/$runLog.bak3" ]; then
				echo -e "\e[31;44mArchive full! Highly advise deleting the log files and/or backups. This message will keep showing otherwise. File $HOME/.logs/$runLog.bak$i exists.\e[0m"
			fi
		done
	fi
fi
